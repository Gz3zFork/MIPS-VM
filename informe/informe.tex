\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{float}
\begin{document}
\title{
Trabajo Práctico Final \\
\large R-222 Arquitectura del Computador}
\author{ Lisandro Maselli\\
Román Castellarin\\
Juan Ignacio Suarez}
\maketitle
\section{Introducción}
El proyecto aquí presentado consistió en la investigación de las arquitecturas MIPS, para el consecuente desarrollo de una máquina virtual y un compilador que en conjunto permiten ejecutar código assembly directamente.

El proyecto consta de 2 partes:
\begin{itemize}
\item Un compilador (compuesto de un lexer + parser) que toma código assembly para MIPS y genera un archivo ejecutable para la máquina virtual.
\item Una máquina virtual que toma el archivo generado y lo ejecuta.
\end{itemize}    

\section{Arquitectura MIPS}
En qué consiste, brevemente cómo funciona, ventajas, etc...

En arquitectura computacional, RISC (Reduced Instruction Set Computer) es un tipo de diseño de CPU generalmente utilizado en microprocesadores
o microcontroladores con las siguientes características fundamentales:
\begin{itemize}
\item Instrucciones de tamaño fijo y presentadas en un reducido número de formatos.
\item Sólo las instrucciones de carga y almacenamiento acceden a la memoria de datos.
Con el nombre de MIPS (Microprocessor without Interlocked Pipeline Stages) se conoce a toda una familia de microprocesadores
de arquitectura RISC desarrollados por MIPS Technologies.
\end{itemize}
Para este trabajo elegimos emular  la arquitectura de MIPS I, la cual consta con estas caracteristicas  principales :
\begin{itemize}
\item Ancho de palabra y tamaño de los buses : 32 bits
\item  Tamaño de los datos en las instrucciones:
	\begin{itemize}
	\item Byte (b): 8 bits
	\item Halfword (h): 16 bits
	\item Word (w): 32 bits
	\item Doubleword (d): 64 bits
	\end{itemize}
 \item Arquitectura de carga / almacenamiento:
 	\begin{itemize}
 	\item Antes de ser utilizado en una instrucción aritmética, todo dato debe
 	ser cargado previamente en un registro de proposito general.
 	\item instrucciones aritméticas con 3 operandos de 32 bits en registros.
 	\end{itemize}
\end{itemize}
\subsection{Registros}
En MIPS los registros \$0 a \$31 son de proposito general y pueden emplearse
para contener datos o punteros.\\
Existe un convenio que dota de pseudónimos y usos determinados a todos los
registros del MIPS:
\begin{itemize}
\item \$zero(0): constante 0 (no modificable).
\item \$at(1): uso interno del traductor de ensamblador en pseudoinstrucciones.
\item \$v0 - \$v1(2 - 3): valores de returno de subrutinas.
\item \$a0 - \$a3(4 - 7): argumentos para subrutinas.
\item \$t0 - \$t9(8 - 15 , 24 - 25): variables temporales.
\item \$k0 - \$k1(26 - 27): reservador para el uso del nucleo del SO.
\item \$gp(29): puntero de tabla de datos globales.
\item \$sp(30): puntero de pila.
\item \$fp(31): direccion de returno (usado implicitamente por instruccion jal).
\subsection{Memoria}
La dirección física de la memoria de instrucciones, en modo usuario, empiece en la dirección
0x400000 y termina en 0x0FFFFFFF
\begin{figure}[H]
\includegraphics[width=\textwidth]{gmemory.png}
\end{figure}
\end{itemize}
\iffalse
Las arquitecturas MIPS siguen la filosofía RISC, por lo que cumplen con las siguientes directrices:
\item Es una arquitectura Load-Store, es decir, para operar con datos, estos deben cargarse desde
la memoria principal en registros internos de la CPU, donde quedan disponibles para operar con
ellos. Así, las únicas instrucciones que acceden a memoria principal son las de carga - almacenamiento.
Estando los datos en registros de la CPU, el acceso a ellos es muchísimo más rápido que si estuvieran en memoria principal.
\item Ya que las únicas instrucciones de acceso a memoria principal son las de carga - almacenamiento,
se dispone de pocos y sencillos modos de direccionamiento, lo que facilita
enormemente la decodificación de las instrucciones y la obtención de sus operandos.
\item La organización del formato de las instrucciones también es muy sencillo, lo que facilita su
decodificación, pues dispone de pocos formatos, compartiendo todos la misma longitud fija
de instrucción.
\item Ya que no se opera con los datos en memoria principal, se hace necesario disponer de un
generoso conjunto de registros generales para albergar los distintos datos del programa.
\fi










\subsection{Instrucciones soportadas}
rellenar
    
\section{Compilador}
\subsection{Formato ejecutable .mips}

En un archivo compilado se puede encontrar mucha más información que las instrucciones del programa que codifica, por lo tanto, su formato no sólo depende de la arquitectura, sino además del sistema operativo.

Nuestra MV utiliza el siguiente formato -creado por nosotros- al cual le asignamos extensión .mips.


ARCHIVO EJECUTABLE

- Header (12 bytes):

    4B : data-segment size (in Bytes)

    4B : text-segment size (in bytes)

    4B : main address

- Data Segment (<data-segment size>):

    Addresses start at 0x10000000

- Text Segment (<text-segment size>):

    Addresses start at 0x400000

Ver sección MV para mayor información sobre el mapeo de memoria".

\subsection{Lexer}
\subsection{Parser}
\subsection{Problemas encontrados}
    
   
\section{Máquina virtual}
\subsection{Introducción}
para emular el procesador vamos a mantener todos los registros en memoria y a
medida que se interpretan las instrucciones estos van modificandose.
para eso definimos a los registros como un array de 32 enteros de 32 bits
y 3 variables de enteros de 32 bits para  los registros LO, HI y PC.

la interpretacion de las instrucciones se lleva a cabo primero decodificando
estas y mapeando su significado a una funcion respectiva.
\subsection{Mini SO ficticio}
\subsubsection{Mapeo de memoria}
Redactar bien

Text Segment starts at 0x400000
Data Segment starts at 0x10000000
Heap memory starts at 0x10010000
Stack memory ends at 0x7FFFFFFC
\subsubsection{Syscalls provistas}
Redactar bien

El argumento va en \texttt{\$v0} y las syscalls se enumeran de 1 a 12. ?

\subsection{Modulos}
\subsubsection{Syscalls}
enum \{
    SC\_PRINT\_INTEGER    = 1,
    SC\_PRINT\_FLOAT      = 2,
    SC\_PRINT\_DOUBLE     = 3,
    SC\_PRINT\_STRING     = 4,
    SC\_READ\_INTEGER     = 5,
    SC\_READ\_FLOAT       = 6,
    SC\_READ\_DOUBLE      = 7,
    SC\_READ\_STRING      = 8,
    SC\_MALLOC           = 9,
    SC\_EXIT             = 10,
    SC\_PRINT\_CHAR       = 11,
    SC\_READ\_CHAR        = 12
    // maybe add more?
\};
\subsubsection{Simulator}
\subsubsection{Regs}
\subsubsection{Memory}
\subsubsection{Instructions}
\subsubsection{Files}





\subsection{Notas y problemas encontrados}
earlier this week:
	We don't understand how memory should be mapped in a multitask OS. We leave that aside. Our simulation is simplified so as to not need \($gp)\ register and alikes.

	We try to understand how to encode the data segment into an executable. We find out that depends on the OS and has nothng to do with MIPS architecture. We invent own our executable format.

	Does the PC always point to the current instruction? Yes. We dug into the matter and discovered the truth.

15/03:
	We add support for floating point types, we struggle trying to find a way to check during compilation time that the machine is compliant with IEEE754 standards.

18-19/03:
    Stack and Heap successfully virtualized!

20/03:
	Modified the executable's header to include the 'main' memory address (where the program starts).

26/03:
	Spent the whole day trying to discover a bug in the compiler which happened to be we had misopened a file in text mode rather than binarily.

\end{document}