\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\begin{document}
\title{
Trabajo Práctico Final \\
\large R-222 Arquitectura del Computador}
\author{ Lisandro Maselli\\
Román Castellarin\\
Juan Ignacio Suarez}
\maketitle
\section{Introducción}
El proyecto aquí presentado consistió en la investigación de las arquitecturas MIPS, para el consecuente desarrollo de una máquina virtual y un compilador que en conjunto permiten ejecutar código assembly directamente.

El proyecto consta de 2 partes:
\begin{itemize}
\item Un compilador (compuesto de un lexer + parser) que toma código assembly para MIPS y genera un archivo ejecutable para la máquina virtual.
\item Una máquina virtual que toma el archivo generado y lo ejecuta.
\end{itemize}    

\section{Arquitectura MIPS}
En qué consiste, brevemente cómo funciona, ventajas, etc...
\subsection{Instrucciones soportadas}
rellenar
    
\section{Compilador}
\subsection{Formato ejecutable .mips}

En un archivo compilado se puede encontrar mucha más información que las instrucciones del programa que codifica, por lo tanto, su formato no sólo depende de la arquitectura, sino además del sistema operativo.

Nuestra MV utiliza el siguiente formato -creado por nosotros- al cual le asignamos extensión .mips.


ARCHIVO EJECUTABLE

- Header (12 bytes):

    4B : data-segment size (in Bytes)

    4B : text-segment size (in bytes)

    4B : main address

- Data Segment (<data-segment size>):

    Addresses start at 0x10000000

- Text Segment (<text-segment size>):

    Addresses start at 0x400000

Ver sección MV para mayor información sobre el mapeo de memoria".

\subsection{Lexer}
\subsection{Parser}
\subsection{Problemas encontrados}
    
   
\section{Máquina virtual}
\subsection{Introducción}
para emular el procesador vamos a mantener todos los registros en memoria y a
medida que se interpretan las instrucciones estos van modificandose.
para eso definimos a los registros como un array de 32 enteros de 32 bits
y 3 variables de enteros de 32 bits para  los registros LO, HI y PC.

la interpretacion de las instrucciones se lleva a cabo primero decodificando
estas y mapeando su significado a una funcion respectiva.
\subsection{Mini SO ficticio}
\subsubsection{Mapeo de memoria}
Redactar bien

Text Segment starts at 0x400000
Data Segment starts at 0x10000000
Heap memory starts at 0x10010000
Stack memory ends at 0x7FFFFFFC
\subsubsection{Syscalls provistas}
Redactar bien

El argumento va en \texttt{\$v0} y las syscalls se enumeran de 1 a 12. ?

\subsection{Modulos}
\subsubsection{Syscalls}
enum \{
    SC\_PRINT\_INTEGER    = 1,
    SC\_PRINT\_FLOAT      = 2,
    SC\_PRINT\_DOUBLE     = 3,
    SC\_PRINT\_STRING     = 4,
    SC\_READ\_INTEGER     = 5,
    SC\_READ\_FLOAT       = 6,
    SC\_READ\_DOUBLE      = 7,
    SC\_READ\_STRING      = 8,
    SC\_MALLOC           = 9,
    SC\_EXIT             = 10,
    SC\_PRINT\_CHAR       = 11,
    SC\_READ\_CHAR        = 12
    // maybe add more?
\};
\subsubsection{Simulator}
\subsubsection{Regs}
\subsubsection{Memory}
\subsubsection{Instructions}
\subsubsection{Files}





\subsection{Notas y problemas encontrados}
earlier this week:
	We don't understand how memory should be mapped in a multitask OS. We leave that aside. Our simulation is simplified so as to not need \($gp)\ register and alikes.

	We try to understand how to encode the data segment into an executable. We find out that depends on the OS and has nothng to do with MIPS architecture. We invent own our executable format.

	Does the PC always point to the current instruction? Yes. We dug into the matter and discovered the truth.

15/03:
	We add support for floating point types, we struggle trying to find a way to check during compilation time that the machine is compliant with IEEE754 standards.

18-19/03:
    Stack and Heap successfully virtualized!

20/03:
	Modified the executable's header to include the 'main' memory address (where the program starts).

26/03:
	Spent the whole day trying to discover a bug in the compiler which happened to be we had misopened a file in text mode rather than binarily.

\end{document}